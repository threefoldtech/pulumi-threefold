// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package provider

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/threefoldtech/pulumi-threefold/sdk/go/threefold/internal"
)

var _ = internal.GetEnvOrDefault

type Backend struct {
	Address   string `pulumi:"address"`
	Namespace string `pulumi:"namespace"`
	Password  string `pulumi:"password"`
}

// BackendInput is an input type that accepts BackendArgs and BackendOutput values.
// You can construct a concrete instance of `BackendInput` via:
//
//	BackendArgs{...}
type BackendInput interface {
	pulumi.Input

	ToBackendOutput() BackendOutput
	ToBackendOutputWithContext(context.Context) BackendOutput
}

type BackendArgs struct {
	Address   pulumi.StringInput `pulumi:"address"`
	Namespace pulumi.StringInput `pulumi:"namespace"`
	Password  pulumi.StringInput `pulumi:"password"`
}

func (BackendArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Backend)(nil)).Elem()
}

func (i BackendArgs) ToBackendOutput() BackendOutput {
	return i.ToBackendOutputWithContext(context.Background())
}

func (i BackendArgs) ToBackendOutputWithContext(ctx context.Context) BackendOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BackendOutput)
}

// BackendArrayInput is an input type that accepts BackendArray and BackendArrayOutput values.
// You can construct a concrete instance of `BackendArrayInput` via:
//
//	BackendArray{ BackendArgs{...} }
type BackendArrayInput interface {
	pulumi.Input

	ToBackendArrayOutput() BackendArrayOutput
	ToBackendArrayOutputWithContext(context.Context) BackendArrayOutput
}

type BackendArray []BackendInput

func (BackendArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Backend)(nil)).Elem()
}

func (i BackendArray) ToBackendArrayOutput() BackendArrayOutput {
	return i.ToBackendArrayOutputWithContext(context.Background())
}

func (i BackendArray) ToBackendArrayOutputWithContext(ctx context.Context) BackendArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(BackendArrayOutput)
}

type BackendOutput struct{ *pulumi.OutputState }

func (BackendOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Backend)(nil)).Elem()
}

func (o BackendOutput) ToBackendOutput() BackendOutput {
	return o
}

func (o BackendOutput) ToBackendOutputWithContext(ctx context.Context) BackendOutput {
	return o
}

func (o BackendOutput) Address() pulumi.StringOutput {
	return o.ApplyT(func(v Backend) string { return v.Address }).(pulumi.StringOutput)
}

func (o BackendOutput) Namespace() pulumi.StringOutput {
	return o.ApplyT(func(v Backend) string { return v.Namespace }).(pulumi.StringOutput)
}

func (o BackendOutput) Password() pulumi.StringOutput {
	return o.ApplyT(func(v Backend) string { return v.Password }).(pulumi.StringOutput)
}

type BackendArrayOutput struct{ *pulumi.OutputState }

func (BackendArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Backend)(nil)).Elem()
}

func (o BackendArrayOutput) ToBackendArrayOutput() BackendArrayOutput {
	return o
}

func (o BackendArrayOutput) ToBackendArrayOutputWithContext(ctx context.Context) BackendArrayOutput {
	return o
}

func (o BackendArrayOutput) Index(i pulumi.IntInput) BackendOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Backend {
		return vs[0].([]Backend)[vs[1].(int)]
	}).(BackendOutput)
}

type Disk struct {
	Description *string `pulumi:"description"`
	Name        string  `pulumi:"name"`
	Size        int     `pulumi:"size"`
}

// DiskInput is an input type that accepts DiskArgs and DiskOutput values.
// You can construct a concrete instance of `DiskInput` via:
//
//	DiskArgs{...}
type DiskInput interface {
	pulumi.Input

	ToDiskOutput() DiskOutput
	ToDiskOutputWithContext(context.Context) DiskOutput
}

type DiskArgs struct {
	Description pulumi.StringPtrInput `pulumi:"description"`
	Name        pulumi.StringInput    `pulumi:"name"`
	Size        pulumi.IntInput       `pulumi:"size"`
}

func (DiskArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Disk)(nil)).Elem()
}

func (i DiskArgs) ToDiskOutput() DiskOutput {
	return i.ToDiskOutputWithContext(context.Background())
}

func (i DiskArgs) ToDiskOutputWithContext(ctx context.Context) DiskOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DiskOutput)
}

// DiskArrayInput is an input type that accepts DiskArray and DiskArrayOutput values.
// You can construct a concrete instance of `DiskArrayInput` via:
//
//	DiskArray{ DiskArgs{...} }
type DiskArrayInput interface {
	pulumi.Input

	ToDiskArrayOutput() DiskArrayOutput
	ToDiskArrayOutputWithContext(context.Context) DiskArrayOutput
}

type DiskArray []DiskInput

func (DiskArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Disk)(nil)).Elem()
}

func (i DiskArray) ToDiskArrayOutput() DiskArrayOutput {
	return i.ToDiskArrayOutputWithContext(context.Background())
}

func (i DiskArray) ToDiskArrayOutputWithContext(ctx context.Context) DiskArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DiskArrayOutput)
}

type DiskOutput struct{ *pulumi.OutputState }

func (DiskOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Disk)(nil)).Elem()
}

func (o DiskOutput) ToDiskOutput() DiskOutput {
	return o
}

func (o DiskOutput) ToDiskOutputWithContext(ctx context.Context) DiskOutput {
	return o
}

func (o DiskOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Disk) *string { return v.Description }).(pulumi.StringPtrOutput)
}

func (o DiskOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v Disk) string { return v.Name }).(pulumi.StringOutput)
}

func (o DiskOutput) Size() pulumi.IntOutput {
	return o.ApplyT(func(v Disk) int { return v.Size }).(pulumi.IntOutput)
}

type DiskArrayOutput struct{ *pulumi.OutputState }

func (DiskArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Disk)(nil)).Elem()
}

func (o DiskArrayOutput) ToDiskArrayOutput() DiskArrayOutput {
	return o
}

func (o DiskArrayOutput) ToDiskArrayOutputWithContext(ctx context.Context) DiskArrayOutput {
	return o
}

func (o DiskArrayOutput) Index(i pulumi.IntInput) DiskOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Disk {
		return vs[0].([]Disk)[vs[1].(int)]
	}).(DiskOutput)
}

type Group struct {
	Backends []Backend `pulumi:"backends"`
}

// GroupInput is an input type that accepts GroupArgs and GroupOutput values.
// You can construct a concrete instance of `GroupInput` via:
//
//	GroupArgs{...}
type GroupInput interface {
	pulumi.Input

	ToGroupOutput() GroupOutput
	ToGroupOutputWithContext(context.Context) GroupOutput
}

type GroupArgs struct {
	Backends BackendArrayInput `pulumi:"backends"`
}

func (GroupArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Group)(nil)).Elem()
}

func (i GroupArgs) ToGroupOutput() GroupOutput {
	return i.ToGroupOutputWithContext(context.Background())
}

func (i GroupArgs) ToGroupOutputWithContext(ctx context.Context) GroupOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupOutput)
}

// GroupArrayInput is an input type that accepts GroupArray and GroupArrayOutput values.
// You can construct a concrete instance of `GroupArrayInput` via:
//
//	GroupArray{ GroupArgs{...} }
type GroupArrayInput interface {
	pulumi.Input

	ToGroupArrayOutput() GroupArrayOutput
	ToGroupArrayOutputWithContext(context.Context) GroupArrayOutput
}

type GroupArray []GroupInput

func (GroupArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Group)(nil)).Elem()
}

func (i GroupArray) ToGroupArrayOutput() GroupArrayOutput {
	return i.ToGroupArrayOutputWithContext(context.Background())
}

func (i GroupArray) ToGroupArrayOutputWithContext(ctx context.Context) GroupArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(GroupArrayOutput)
}

type GroupOutput struct{ *pulumi.OutputState }

func (GroupOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Group)(nil)).Elem()
}

func (o GroupOutput) ToGroupOutput() GroupOutput {
	return o
}

func (o GroupOutput) ToGroupOutputWithContext(ctx context.Context) GroupOutput {
	return o
}

func (o GroupOutput) Backends() BackendArrayOutput {
	return o.ApplyT(func(v Group) []Backend { return v.Backends }).(BackendArrayOutput)
}

type GroupArrayOutput struct{ *pulumi.OutputState }

func (GroupArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Group)(nil)).Elem()
}

func (o GroupArrayOutput) ToGroupArrayOutput() GroupArrayOutput {
	return o
}

func (o GroupArrayOutput) ToGroupArrayOutputWithContext(ctx context.Context) GroupArrayOutput {
	return o
}

func (o GroupArrayOutput) Index(i pulumi.IntInput) GroupOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Group {
		return vs[0].([]Group)[vs[1].(int)]
	}).(GroupOutput)
}

type K8sNodeComputed struct {
	Computed_ip  string `pulumi:"computed_ip"`
	Computed_ip6 string `pulumi:"computed_ip6"`
	Console_url  string `pulumi:"console_url"`
	Ip           string `pulumi:"ip"`
	Network_name string `pulumi:"network_name"`
	Ssh_key      string `pulumi:"ssh_key"`
	Token        string `pulumi:"token"`
	Ygg_ip       string `pulumi:"ygg_ip"`
}

// K8sNodeComputedInput is an input type that accepts K8sNodeComputedArgs and K8sNodeComputedOutput values.
// You can construct a concrete instance of `K8sNodeComputedInput` via:
//
//	K8sNodeComputedArgs{...}
type K8sNodeComputedInput interface {
	pulumi.Input

	ToK8sNodeComputedOutput() K8sNodeComputedOutput
	ToK8sNodeComputedOutputWithContext(context.Context) K8sNodeComputedOutput
}

type K8sNodeComputedArgs struct {
	Computed_ip  pulumi.StringInput `pulumi:"computed_ip"`
	Computed_ip6 pulumi.StringInput `pulumi:"computed_ip6"`
	Console_url  pulumi.StringInput `pulumi:"console_url"`
	Ip           pulumi.StringInput `pulumi:"ip"`
	Network_name pulumi.StringInput `pulumi:"network_name"`
	Ssh_key      pulumi.StringInput `pulumi:"ssh_key"`
	Token        pulumi.StringInput `pulumi:"token"`
	Ygg_ip       pulumi.StringInput `pulumi:"ygg_ip"`
}

func (K8sNodeComputedArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*K8sNodeComputed)(nil)).Elem()
}

func (i K8sNodeComputedArgs) ToK8sNodeComputedOutput() K8sNodeComputedOutput {
	return i.ToK8sNodeComputedOutputWithContext(context.Background())
}

func (i K8sNodeComputedArgs) ToK8sNodeComputedOutputWithContext(ctx context.Context) K8sNodeComputedOutput {
	return pulumi.ToOutputWithContext(ctx, i).(K8sNodeComputedOutput)
}

// K8sNodeComputedMapInput is an input type that accepts K8sNodeComputedMap and K8sNodeComputedMapOutput values.
// You can construct a concrete instance of `K8sNodeComputedMapInput` via:
//
//	K8sNodeComputedMap{ "key": K8sNodeComputedArgs{...} }
type K8sNodeComputedMapInput interface {
	pulumi.Input

	ToK8sNodeComputedMapOutput() K8sNodeComputedMapOutput
	ToK8sNodeComputedMapOutputWithContext(context.Context) K8sNodeComputedMapOutput
}

type K8sNodeComputedMap map[string]K8sNodeComputedInput

func (K8sNodeComputedMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]K8sNodeComputed)(nil)).Elem()
}

func (i K8sNodeComputedMap) ToK8sNodeComputedMapOutput() K8sNodeComputedMapOutput {
	return i.ToK8sNodeComputedMapOutputWithContext(context.Background())
}

func (i K8sNodeComputedMap) ToK8sNodeComputedMapOutputWithContext(ctx context.Context) K8sNodeComputedMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(K8sNodeComputedMapOutput)
}

type K8sNodeComputedOutput struct{ *pulumi.OutputState }

func (K8sNodeComputedOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*K8sNodeComputed)(nil)).Elem()
}

func (o K8sNodeComputedOutput) ToK8sNodeComputedOutput() K8sNodeComputedOutput {
	return o
}

func (o K8sNodeComputedOutput) ToK8sNodeComputedOutputWithContext(ctx context.Context) K8sNodeComputedOutput {
	return o
}

func (o K8sNodeComputedOutput) Computed_ip() pulumi.StringOutput {
	return o.ApplyT(func(v K8sNodeComputed) string { return v.Computed_ip }).(pulumi.StringOutput)
}

func (o K8sNodeComputedOutput) Computed_ip6() pulumi.StringOutput {
	return o.ApplyT(func(v K8sNodeComputed) string { return v.Computed_ip6 }).(pulumi.StringOutput)
}

func (o K8sNodeComputedOutput) Console_url() pulumi.StringOutput {
	return o.ApplyT(func(v K8sNodeComputed) string { return v.Console_url }).(pulumi.StringOutput)
}

func (o K8sNodeComputedOutput) Ip() pulumi.StringOutput {
	return o.ApplyT(func(v K8sNodeComputed) string { return v.Ip }).(pulumi.StringOutput)
}

func (o K8sNodeComputedOutput) Network_name() pulumi.StringOutput {
	return o.ApplyT(func(v K8sNodeComputed) string { return v.Network_name }).(pulumi.StringOutput)
}

func (o K8sNodeComputedOutput) Ssh_key() pulumi.StringOutput {
	return o.ApplyT(func(v K8sNodeComputed) string { return v.Ssh_key }).(pulumi.StringOutput)
}

func (o K8sNodeComputedOutput) Token() pulumi.StringOutput {
	return o.ApplyT(func(v K8sNodeComputed) string { return v.Token }).(pulumi.StringOutput)
}

func (o K8sNodeComputedOutput) Ygg_ip() pulumi.StringOutput {
	return o.ApplyT(func(v K8sNodeComputed) string { return v.Ygg_ip }).(pulumi.StringOutput)
}

type K8sNodeComputedMapOutput struct{ *pulumi.OutputState }

func (K8sNodeComputedMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]K8sNodeComputed)(nil)).Elem()
}

func (o K8sNodeComputedMapOutput) ToK8sNodeComputedMapOutput() K8sNodeComputedMapOutput {
	return o
}

func (o K8sNodeComputedMapOutput) ToK8sNodeComputedMapOutputWithContext(ctx context.Context) K8sNodeComputedMapOutput {
	return o
}

func (o K8sNodeComputedMapOutput) MapIndex(k pulumi.StringInput) K8sNodeComputedOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) K8sNodeComputed {
		return vs[0].(map[string]K8sNodeComputed)[vs[1].(string)]
	}).(K8sNodeComputedOutput)
}

type K8sNodeInput struct {
	Cpu            int         `pulumi:"cpu"`
	Disk_size      int         `pulumi:"disk_size"`
	Flist          *string     `pulumi:"flist"`
	Flist_checksum *string     `pulumi:"flist_checksum"`
	Memory         int         `pulumi:"memory"`
	Name           string      `pulumi:"name"`
	Node           interface{} `pulumi:"node"`
	Planetary      *bool       `pulumi:"planetary"`
	Public_ip      *bool       `pulumi:"public_ip"`
	Public_ip6     *bool       `pulumi:"public_ip6"`
}

// K8sNodeInputInput is an input type that accepts K8sNodeInputArgs and K8sNodeInputOutput values.
// You can construct a concrete instance of `K8sNodeInputInput` via:
//
//	K8sNodeInputArgs{...}
type K8sNodeInputInput interface {
	pulumi.Input

	ToK8sNodeInputOutput() K8sNodeInputOutput
	ToK8sNodeInputOutputWithContext(context.Context) K8sNodeInputOutput
}

type K8sNodeInputArgs struct {
	Cpu            pulumi.IntInput       `pulumi:"cpu"`
	Disk_size      pulumi.IntInput       `pulumi:"disk_size"`
	Flist          pulumi.StringPtrInput `pulumi:"flist"`
	Flist_checksum pulumi.StringPtrInput `pulumi:"flist_checksum"`
	Memory         pulumi.IntInput       `pulumi:"memory"`
	Name           pulumi.StringInput    `pulumi:"name"`
	Node           pulumi.Input          `pulumi:"node"`
	Planetary      pulumi.BoolPtrInput   `pulumi:"planetary"`
	Public_ip      pulumi.BoolPtrInput   `pulumi:"public_ip"`
	Public_ip6     pulumi.BoolPtrInput   `pulumi:"public_ip6"`
}

func (K8sNodeInputArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*K8sNodeInput)(nil)).Elem()
}

func (i K8sNodeInputArgs) ToK8sNodeInputOutput() K8sNodeInputOutput {
	return i.ToK8sNodeInputOutputWithContext(context.Background())
}

func (i K8sNodeInputArgs) ToK8sNodeInputOutputWithContext(ctx context.Context) K8sNodeInputOutput {
	return pulumi.ToOutputWithContext(ctx, i).(K8sNodeInputOutput)
}

// K8sNodeInputArrayInput is an input type that accepts K8sNodeInputArray and K8sNodeInputArrayOutput values.
// You can construct a concrete instance of `K8sNodeInputArrayInput` via:
//
//	K8sNodeInputArray{ K8sNodeInputArgs{...} }
type K8sNodeInputArrayInput interface {
	pulumi.Input

	ToK8sNodeInputArrayOutput() K8sNodeInputArrayOutput
	ToK8sNodeInputArrayOutputWithContext(context.Context) K8sNodeInputArrayOutput
}

type K8sNodeInputArray []K8sNodeInputInput

func (K8sNodeInputArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]K8sNodeInput)(nil)).Elem()
}

func (i K8sNodeInputArray) ToK8sNodeInputArrayOutput() K8sNodeInputArrayOutput {
	return i.ToK8sNodeInputArrayOutputWithContext(context.Background())
}

func (i K8sNodeInputArray) ToK8sNodeInputArrayOutputWithContext(ctx context.Context) K8sNodeInputArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(K8sNodeInputArrayOutput)
}

type K8sNodeInputOutput struct{ *pulumi.OutputState }

func (K8sNodeInputOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*K8sNodeInput)(nil)).Elem()
}

func (o K8sNodeInputOutput) ToK8sNodeInputOutput() K8sNodeInputOutput {
	return o
}

func (o K8sNodeInputOutput) ToK8sNodeInputOutputWithContext(ctx context.Context) K8sNodeInputOutput {
	return o
}

func (o K8sNodeInputOutput) Cpu() pulumi.IntOutput {
	return o.ApplyT(func(v K8sNodeInput) int { return v.Cpu }).(pulumi.IntOutput)
}

func (o K8sNodeInputOutput) Disk_size() pulumi.IntOutput {
	return o.ApplyT(func(v K8sNodeInput) int { return v.Disk_size }).(pulumi.IntOutput)
}

func (o K8sNodeInputOutput) Flist() pulumi.StringPtrOutput {
	return o.ApplyT(func(v K8sNodeInput) *string { return v.Flist }).(pulumi.StringPtrOutput)
}

func (o K8sNodeInputOutput) Flist_checksum() pulumi.StringPtrOutput {
	return o.ApplyT(func(v K8sNodeInput) *string { return v.Flist_checksum }).(pulumi.StringPtrOutput)
}

func (o K8sNodeInputOutput) Memory() pulumi.IntOutput {
	return o.ApplyT(func(v K8sNodeInput) int { return v.Memory }).(pulumi.IntOutput)
}

func (o K8sNodeInputOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v K8sNodeInput) string { return v.Name }).(pulumi.StringOutput)
}

func (o K8sNodeInputOutput) Node() pulumi.AnyOutput {
	return o.ApplyT(func(v K8sNodeInput) interface{} { return v.Node }).(pulumi.AnyOutput)
}

func (o K8sNodeInputOutput) Planetary() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v K8sNodeInput) *bool { return v.Planetary }).(pulumi.BoolPtrOutput)
}

func (o K8sNodeInputOutput) Public_ip() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v K8sNodeInput) *bool { return v.Public_ip }).(pulumi.BoolPtrOutput)
}

func (o K8sNodeInputOutput) Public_ip6() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v K8sNodeInput) *bool { return v.Public_ip6 }).(pulumi.BoolPtrOutput)
}

type K8sNodeInputArrayOutput struct{ *pulumi.OutputState }

func (K8sNodeInputArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]K8sNodeInput)(nil)).Elem()
}

func (o K8sNodeInputArrayOutput) ToK8sNodeInputArrayOutput() K8sNodeInputArrayOutput {
	return o
}

func (o K8sNodeInputArrayOutput) ToK8sNodeInputArrayOutputWithContext(ctx context.Context) K8sNodeInputArrayOutput {
	return o
}

func (o K8sNodeInputArrayOutput) Index(i pulumi.IntInput) K8sNodeInputOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) K8sNodeInput {
		return vs[0].([]K8sNodeInput)[vs[1].(int)]
	}).(K8sNodeInputOutput)
}

type Metadata struct {
	Backends             []Backend `pulumi:"backends"`
	Encryption_algorithm *string   `pulumi:"encryption_algorithm"`
	Encryption_key       string    `pulumi:"encryption_key"`
	Prefix               string    `pulumi:"prefix"`
	Type                 *string   `pulumi:"type"`
}

// MetadataInput is an input type that accepts MetadataArgs and MetadataOutput values.
// You can construct a concrete instance of `MetadataInput` via:
//
//	MetadataArgs{...}
type MetadataInput interface {
	pulumi.Input

	ToMetadataOutput() MetadataOutput
	ToMetadataOutputWithContext(context.Context) MetadataOutput
}

type MetadataArgs struct {
	Backends             BackendArrayInput     `pulumi:"backends"`
	Encryption_algorithm pulumi.StringPtrInput `pulumi:"encryption_algorithm"`
	Encryption_key       pulumi.StringInput    `pulumi:"encryption_key"`
	Prefix               pulumi.StringInput    `pulumi:"prefix"`
	Type                 pulumi.StringPtrInput `pulumi:"type"`
}

func (MetadataArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Metadata)(nil)).Elem()
}

func (i MetadataArgs) ToMetadataOutput() MetadataOutput {
	return i.ToMetadataOutputWithContext(context.Background())
}

func (i MetadataArgs) ToMetadataOutputWithContext(ctx context.Context) MetadataOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetadataOutput)
}

type MetadataOutput struct{ *pulumi.OutputState }

func (MetadataOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Metadata)(nil)).Elem()
}

func (o MetadataOutput) ToMetadataOutput() MetadataOutput {
	return o
}

func (o MetadataOutput) ToMetadataOutputWithContext(ctx context.Context) MetadataOutput {
	return o
}

func (o MetadataOutput) Backends() BackendArrayOutput {
	return o.ApplyT(func(v Metadata) []Backend { return v.Backends }).(BackendArrayOutput)
}

func (o MetadataOutput) Encryption_algorithm() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Metadata) *string { return v.Encryption_algorithm }).(pulumi.StringPtrOutput)
}

func (o MetadataOutput) Encryption_key() pulumi.StringOutput {
	return o.ApplyT(func(v Metadata) string { return v.Encryption_key }).(pulumi.StringOutput)
}

func (o MetadataOutput) Prefix() pulumi.StringOutput {
	return o.ApplyT(func(v Metadata) string { return v.Prefix }).(pulumi.StringOutput)
}

func (o MetadataOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v Metadata) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type Mount struct {
	Disk_name   string `pulumi:"disk_name"`
	Mount_point string `pulumi:"mount_point"`
}

// MountInput is an input type that accepts MountArgs and MountOutput values.
// You can construct a concrete instance of `MountInput` via:
//
//	MountArgs{...}
type MountInput interface {
	pulumi.Input

	ToMountOutput() MountOutput
	ToMountOutputWithContext(context.Context) MountOutput
}

type MountArgs struct {
	Disk_name   pulumi.StringInput `pulumi:"disk_name"`
	Mount_point pulumi.StringInput `pulumi:"mount_point"`
}

func (MountArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Mount)(nil)).Elem()
}

func (i MountArgs) ToMountOutput() MountOutput {
	return i.ToMountOutputWithContext(context.Background())
}

func (i MountArgs) ToMountOutputWithContext(ctx context.Context) MountOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MountOutput)
}

// MountArrayInput is an input type that accepts MountArray and MountArrayOutput values.
// You can construct a concrete instance of `MountArrayInput` via:
//
//	MountArray{ MountArgs{...} }
type MountArrayInput interface {
	pulumi.Input

	ToMountArrayOutput() MountArrayOutput
	ToMountArrayOutputWithContext(context.Context) MountArrayOutput
}

type MountArray []MountInput

func (MountArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Mount)(nil)).Elem()
}

func (i MountArray) ToMountArrayOutput() MountArrayOutput {
	return i.ToMountArrayOutputWithContext(context.Background())
}

func (i MountArray) ToMountArrayOutputWithContext(ctx context.Context) MountArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MountArrayOutput)
}

type MountOutput struct{ *pulumi.OutputState }

func (MountOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Mount)(nil)).Elem()
}

func (o MountOutput) ToMountOutput() MountOutput {
	return o
}

func (o MountOutput) ToMountOutputWithContext(ctx context.Context) MountOutput {
	return o
}

func (o MountOutput) Disk_name() pulumi.StringOutput {
	return o.ApplyT(func(v Mount) string { return v.Disk_name }).(pulumi.StringOutput)
}

func (o MountOutput) Mount_point() pulumi.StringOutput {
	return o.ApplyT(func(v Mount) string { return v.Mount_point }).(pulumi.StringOutput)
}

type MountArrayOutput struct{ *pulumi.OutputState }

func (MountArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Mount)(nil)).Elem()
}

func (o MountArrayOutput) ToMountArrayOutput() MountArrayOutput {
	return o
}

func (o MountArrayOutput) ToMountArrayOutputWithContext(ctx context.Context) MountArrayOutput {
	return o
}

func (o MountArrayOutput) Index(i pulumi.IntInput) MountOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Mount {
		return vs[0].([]Mount)[vs[1].(int)]
	}).(MountOutput)
}

type QSFSComputed struct {
	Metrics_endpoint string `pulumi:"metrics_endpoint"`
}

// QSFSComputedInput is an input type that accepts QSFSComputedArgs and QSFSComputedOutput values.
// You can construct a concrete instance of `QSFSComputedInput` via:
//
//	QSFSComputedArgs{...}
type QSFSComputedInput interface {
	pulumi.Input

	ToQSFSComputedOutput() QSFSComputedOutput
	ToQSFSComputedOutputWithContext(context.Context) QSFSComputedOutput
}

type QSFSComputedArgs struct {
	Metrics_endpoint pulumi.StringInput `pulumi:"metrics_endpoint"`
}

func (QSFSComputedArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*QSFSComputed)(nil)).Elem()
}

func (i QSFSComputedArgs) ToQSFSComputedOutput() QSFSComputedOutput {
	return i.ToQSFSComputedOutputWithContext(context.Background())
}

func (i QSFSComputedArgs) ToQSFSComputedOutputWithContext(ctx context.Context) QSFSComputedOutput {
	return pulumi.ToOutputWithContext(ctx, i).(QSFSComputedOutput)
}

// QSFSComputedArrayInput is an input type that accepts QSFSComputedArray and QSFSComputedArrayOutput values.
// You can construct a concrete instance of `QSFSComputedArrayInput` via:
//
//	QSFSComputedArray{ QSFSComputedArgs{...} }
type QSFSComputedArrayInput interface {
	pulumi.Input

	ToQSFSComputedArrayOutput() QSFSComputedArrayOutput
	ToQSFSComputedArrayOutputWithContext(context.Context) QSFSComputedArrayOutput
}

type QSFSComputedArray []QSFSComputedInput

func (QSFSComputedArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]QSFSComputed)(nil)).Elem()
}

func (i QSFSComputedArray) ToQSFSComputedArrayOutput() QSFSComputedArrayOutput {
	return i.ToQSFSComputedArrayOutputWithContext(context.Background())
}

func (i QSFSComputedArray) ToQSFSComputedArrayOutputWithContext(ctx context.Context) QSFSComputedArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(QSFSComputedArrayOutput)
}

type QSFSComputedOutput struct{ *pulumi.OutputState }

func (QSFSComputedOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*QSFSComputed)(nil)).Elem()
}

func (o QSFSComputedOutput) ToQSFSComputedOutput() QSFSComputedOutput {
	return o
}

func (o QSFSComputedOutput) ToQSFSComputedOutputWithContext(ctx context.Context) QSFSComputedOutput {
	return o
}

func (o QSFSComputedOutput) Metrics_endpoint() pulumi.StringOutput {
	return o.ApplyT(func(v QSFSComputed) string { return v.Metrics_endpoint }).(pulumi.StringOutput)
}

type QSFSComputedArrayOutput struct{ *pulumi.OutputState }

func (QSFSComputedArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]QSFSComputed)(nil)).Elem()
}

func (o QSFSComputedArrayOutput) ToQSFSComputedArrayOutput() QSFSComputedArrayOutput {
	return o
}

func (o QSFSComputedArrayOutput) ToQSFSComputedArrayOutputWithContext(ctx context.Context) QSFSComputedArrayOutput {
	return o
}

func (o QSFSComputedArrayOutput) Index(i pulumi.IntInput) QSFSComputedOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) QSFSComputed {
		return vs[0].([]QSFSComputed)[vs[1].(int)]
	}).(QSFSComputedOutput)
}

type QSFSInput struct {
	Cache                 int      `pulumi:"cache"`
	Compression_algorithm *string  `pulumi:"compression_algorithm"`
	Description           *string  `pulumi:"description"`
	Encryption_algorithm  *string  `pulumi:"encryption_algorithm"`
	Encryption_key        string   `pulumi:"encryption_key"`
	Expected_shards       int      `pulumi:"expected_shards"`
	Groups                []Group  `pulumi:"groups"`
	Max_zdb_data_dir_size int      `pulumi:"max_zdb_data_dir_size"`
	Metadata              Metadata `pulumi:"metadata"`
	Minimal_shards        int      `pulumi:"minimal_shards"`
	Name                  string   `pulumi:"name"`
	Redundant_groups      int      `pulumi:"redundant_groups"`
	Redundant_nodes       int      `pulumi:"redundant_nodes"`
}

// QSFSInputInput is an input type that accepts QSFSInputArgs and QSFSInputOutput values.
// You can construct a concrete instance of `QSFSInputInput` via:
//
//	QSFSInputArgs{...}
type QSFSInputInput interface {
	pulumi.Input

	ToQSFSInputOutput() QSFSInputOutput
	ToQSFSInputOutputWithContext(context.Context) QSFSInputOutput
}

type QSFSInputArgs struct {
	Cache                 pulumi.IntInput       `pulumi:"cache"`
	Compression_algorithm pulumi.StringPtrInput `pulumi:"compression_algorithm"`
	Description           pulumi.StringPtrInput `pulumi:"description"`
	Encryption_algorithm  pulumi.StringPtrInput `pulumi:"encryption_algorithm"`
	Encryption_key        pulumi.StringInput    `pulumi:"encryption_key"`
	Expected_shards       pulumi.IntInput       `pulumi:"expected_shards"`
	Groups                GroupArrayInput       `pulumi:"groups"`
	Max_zdb_data_dir_size pulumi.IntInput       `pulumi:"max_zdb_data_dir_size"`
	Metadata              MetadataInput         `pulumi:"metadata"`
	Minimal_shards        pulumi.IntInput       `pulumi:"minimal_shards"`
	Name                  pulumi.StringInput    `pulumi:"name"`
	Redundant_groups      pulumi.IntInput       `pulumi:"redundant_groups"`
	Redundant_nodes       pulumi.IntInput       `pulumi:"redundant_nodes"`
}

func (QSFSInputArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*QSFSInput)(nil)).Elem()
}

func (i QSFSInputArgs) ToQSFSInputOutput() QSFSInputOutput {
	return i.ToQSFSInputOutputWithContext(context.Background())
}

func (i QSFSInputArgs) ToQSFSInputOutputWithContext(ctx context.Context) QSFSInputOutput {
	return pulumi.ToOutputWithContext(ctx, i).(QSFSInputOutput)
}

// QSFSInputArrayInput is an input type that accepts QSFSInputArray and QSFSInputArrayOutput values.
// You can construct a concrete instance of `QSFSInputArrayInput` via:
//
//	QSFSInputArray{ QSFSInputArgs{...} }
type QSFSInputArrayInput interface {
	pulumi.Input

	ToQSFSInputArrayOutput() QSFSInputArrayOutput
	ToQSFSInputArrayOutputWithContext(context.Context) QSFSInputArrayOutput
}

type QSFSInputArray []QSFSInputInput

func (QSFSInputArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]QSFSInput)(nil)).Elem()
}

func (i QSFSInputArray) ToQSFSInputArrayOutput() QSFSInputArrayOutput {
	return i.ToQSFSInputArrayOutputWithContext(context.Background())
}

func (i QSFSInputArray) ToQSFSInputArrayOutputWithContext(ctx context.Context) QSFSInputArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(QSFSInputArrayOutput)
}

type QSFSInputOutput struct{ *pulumi.OutputState }

func (QSFSInputOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*QSFSInput)(nil)).Elem()
}

func (o QSFSInputOutput) ToQSFSInputOutput() QSFSInputOutput {
	return o
}

func (o QSFSInputOutput) ToQSFSInputOutputWithContext(ctx context.Context) QSFSInputOutput {
	return o
}

func (o QSFSInputOutput) Cache() pulumi.IntOutput {
	return o.ApplyT(func(v QSFSInput) int { return v.Cache }).(pulumi.IntOutput)
}

func (o QSFSInputOutput) Compression_algorithm() pulumi.StringPtrOutput {
	return o.ApplyT(func(v QSFSInput) *string { return v.Compression_algorithm }).(pulumi.StringPtrOutput)
}

func (o QSFSInputOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v QSFSInput) *string { return v.Description }).(pulumi.StringPtrOutput)
}

func (o QSFSInputOutput) Encryption_algorithm() pulumi.StringPtrOutput {
	return o.ApplyT(func(v QSFSInput) *string { return v.Encryption_algorithm }).(pulumi.StringPtrOutput)
}

func (o QSFSInputOutput) Encryption_key() pulumi.StringOutput {
	return o.ApplyT(func(v QSFSInput) string { return v.Encryption_key }).(pulumi.StringOutput)
}

func (o QSFSInputOutput) Expected_shards() pulumi.IntOutput {
	return o.ApplyT(func(v QSFSInput) int { return v.Expected_shards }).(pulumi.IntOutput)
}

func (o QSFSInputOutput) Groups() GroupArrayOutput {
	return o.ApplyT(func(v QSFSInput) []Group { return v.Groups }).(GroupArrayOutput)
}

func (o QSFSInputOutput) Max_zdb_data_dir_size() pulumi.IntOutput {
	return o.ApplyT(func(v QSFSInput) int { return v.Max_zdb_data_dir_size }).(pulumi.IntOutput)
}

func (o QSFSInputOutput) Metadata() MetadataOutput {
	return o.ApplyT(func(v QSFSInput) Metadata { return v.Metadata }).(MetadataOutput)
}

func (o QSFSInputOutput) Minimal_shards() pulumi.IntOutput {
	return o.ApplyT(func(v QSFSInput) int { return v.Minimal_shards }).(pulumi.IntOutput)
}

func (o QSFSInputOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v QSFSInput) string { return v.Name }).(pulumi.StringOutput)
}

func (o QSFSInputOutput) Redundant_groups() pulumi.IntOutput {
	return o.ApplyT(func(v QSFSInput) int { return v.Redundant_groups }).(pulumi.IntOutput)
}

func (o QSFSInputOutput) Redundant_nodes() pulumi.IntOutput {
	return o.ApplyT(func(v QSFSInput) int { return v.Redundant_nodes }).(pulumi.IntOutput)
}

type QSFSInputArrayOutput struct{ *pulumi.OutputState }

func (QSFSInputArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]QSFSInput)(nil)).Elem()
}

func (o QSFSInputArrayOutput) ToQSFSInputArrayOutput() QSFSInputArrayOutput {
	return o
}

func (o QSFSInputArrayOutput) ToQSFSInputArrayOutputWithContext(ctx context.Context) QSFSInputArrayOutput {
	return o
}

func (o QSFSInputArrayOutput) Index(i pulumi.IntInput) QSFSInputOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) QSFSInput {
		return vs[0].([]QSFSInput)[vs[1].(int)]
	}).(QSFSInputOutput)
}

type VMComputed struct {
	Computed_ip  string  `pulumi:"computed_ip"`
	Computed_ip6 string  `pulumi:"computed_ip6"`
	Console_url  string  `pulumi:"console_url"`
	Ip           *string `pulumi:"ip"`
	Ygg_ip       string  `pulumi:"ygg_ip"`
}

// VMComputedInput is an input type that accepts VMComputedArgs and VMComputedOutput values.
// You can construct a concrete instance of `VMComputedInput` via:
//
//	VMComputedArgs{...}
type VMComputedInput interface {
	pulumi.Input

	ToVMComputedOutput() VMComputedOutput
	ToVMComputedOutputWithContext(context.Context) VMComputedOutput
}

type VMComputedArgs struct {
	Computed_ip  pulumi.StringInput    `pulumi:"computed_ip"`
	Computed_ip6 pulumi.StringInput    `pulumi:"computed_ip6"`
	Console_url  pulumi.StringInput    `pulumi:"console_url"`
	Ip           pulumi.StringPtrInput `pulumi:"ip"`
	Ygg_ip       pulumi.StringInput    `pulumi:"ygg_ip"`
}

func (VMComputedArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VMComputed)(nil)).Elem()
}

func (i VMComputedArgs) ToVMComputedOutput() VMComputedOutput {
	return i.ToVMComputedOutputWithContext(context.Background())
}

func (i VMComputedArgs) ToVMComputedOutputWithContext(ctx context.Context) VMComputedOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VMComputedOutput)
}

// VMComputedArrayInput is an input type that accepts VMComputedArray and VMComputedArrayOutput values.
// You can construct a concrete instance of `VMComputedArrayInput` via:
//
//	VMComputedArray{ VMComputedArgs{...} }
type VMComputedArrayInput interface {
	pulumi.Input

	ToVMComputedArrayOutput() VMComputedArrayOutput
	ToVMComputedArrayOutputWithContext(context.Context) VMComputedArrayOutput
}

type VMComputedArray []VMComputedInput

func (VMComputedArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VMComputed)(nil)).Elem()
}

func (i VMComputedArray) ToVMComputedArrayOutput() VMComputedArrayOutput {
	return i.ToVMComputedArrayOutputWithContext(context.Background())
}

func (i VMComputedArray) ToVMComputedArrayOutputWithContext(ctx context.Context) VMComputedArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VMComputedArrayOutput)
}

type VMComputedOutput struct{ *pulumi.OutputState }

func (VMComputedOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VMComputed)(nil)).Elem()
}

func (o VMComputedOutput) ToVMComputedOutput() VMComputedOutput {
	return o
}

func (o VMComputedOutput) ToVMComputedOutputWithContext(ctx context.Context) VMComputedOutput {
	return o
}

func (o VMComputedOutput) Computed_ip() pulumi.StringOutput {
	return o.ApplyT(func(v VMComputed) string { return v.Computed_ip }).(pulumi.StringOutput)
}

func (o VMComputedOutput) Computed_ip6() pulumi.StringOutput {
	return o.ApplyT(func(v VMComputed) string { return v.Computed_ip6 }).(pulumi.StringOutput)
}

func (o VMComputedOutput) Console_url() pulumi.StringOutput {
	return o.ApplyT(func(v VMComputed) string { return v.Console_url }).(pulumi.StringOutput)
}

func (o VMComputedOutput) Ip() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VMComputed) *string { return v.Ip }).(pulumi.StringPtrOutput)
}

func (o VMComputedOutput) Ygg_ip() pulumi.StringOutput {
	return o.ApplyT(func(v VMComputed) string { return v.Ygg_ip }).(pulumi.StringOutput)
}

type VMComputedArrayOutput struct{ *pulumi.OutputState }

func (VMComputedArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VMComputed)(nil)).Elem()
}

func (o VMComputedArrayOutput) ToVMComputedArrayOutput() VMComputedArrayOutput {
	return o
}

func (o VMComputedArrayOutput) ToVMComputedArrayOutputWithContext(ctx context.Context) VMComputedArrayOutput {
	return o
}

func (o VMComputedArrayOutput) Index(i pulumi.IntInput) VMComputedOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VMComputed {
		return vs[0].([]VMComputed)[vs[1].(int)]
	}).(VMComputedOutput)
}

type VMInput struct {
	Cpu            int               `pulumi:"cpu"`
	Description    *string           `pulumi:"description"`
	Entrypoint     *string           `pulumi:"entrypoint"`
	Env_vars       map[string]string `pulumi:"env_vars"`
	Flist          string            `pulumi:"flist"`
	Flist_checksum *string           `pulumi:"flist_checksum"`
	Gpus           []string          `pulumi:"gpus"`
	Memory         int               `pulumi:"memory"`
	Mounts         []Mount           `pulumi:"mounts"`
	Name           string            `pulumi:"name"`
	Network_name   string            `pulumi:"network_name"`
	Planetary      *bool             `pulumi:"planetary"`
	Public_ip      *bool             `pulumi:"public_ip"`
	Public_ip6     *bool             `pulumi:"public_ip6"`
	Rootfs_size    *int              `pulumi:"rootfs_size"`
	Zlogs          []Zlog            `pulumi:"zlogs"`
}

// VMInputInput is an input type that accepts VMInputArgs and VMInputOutput values.
// You can construct a concrete instance of `VMInputInput` via:
//
//	VMInputArgs{...}
type VMInputInput interface {
	pulumi.Input

	ToVMInputOutput() VMInputOutput
	ToVMInputOutputWithContext(context.Context) VMInputOutput
}

type VMInputArgs struct {
	Cpu            pulumi.IntInput         `pulumi:"cpu"`
	Description    pulumi.StringPtrInput   `pulumi:"description"`
	Entrypoint     pulumi.StringPtrInput   `pulumi:"entrypoint"`
	Env_vars       pulumi.StringMapInput   `pulumi:"env_vars"`
	Flist          pulumi.StringInput      `pulumi:"flist"`
	Flist_checksum pulumi.StringPtrInput   `pulumi:"flist_checksum"`
	Gpus           pulumi.StringArrayInput `pulumi:"gpus"`
	Memory         pulumi.IntInput         `pulumi:"memory"`
	Mounts         MountArrayInput         `pulumi:"mounts"`
	Name           pulumi.StringInput      `pulumi:"name"`
	Network_name   pulumi.StringInput      `pulumi:"network_name"`
	Planetary      pulumi.BoolPtrInput     `pulumi:"planetary"`
	Public_ip      pulumi.BoolPtrInput     `pulumi:"public_ip"`
	Public_ip6     pulumi.BoolPtrInput     `pulumi:"public_ip6"`
	Rootfs_size    pulumi.IntPtrInput      `pulumi:"rootfs_size"`
	Zlogs          ZlogArrayInput          `pulumi:"zlogs"`
}

func (VMInputArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*VMInput)(nil)).Elem()
}

func (i VMInputArgs) ToVMInputOutput() VMInputOutput {
	return i.ToVMInputOutputWithContext(context.Background())
}

func (i VMInputArgs) ToVMInputOutputWithContext(ctx context.Context) VMInputOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VMInputOutput)
}

// VMInputArrayInput is an input type that accepts VMInputArray and VMInputArrayOutput values.
// You can construct a concrete instance of `VMInputArrayInput` via:
//
//	VMInputArray{ VMInputArgs{...} }
type VMInputArrayInput interface {
	pulumi.Input

	ToVMInputArrayOutput() VMInputArrayOutput
	ToVMInputArrayOutputWithContext(context.Context) VMInputArrayOutput
}

type VMInputArray []VMInputInput

func (VMInputArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VMInput)(nil)).Elem()
}

func (i VMInputArray) ToVMInputArrayOutput() VMInputArrayOutput {
	return i.ToVMInputArrayOutputWithContext(context.Background())
}

func (i VMInputArray) ToVMInputArrayOutputWithContext(ctx context.Context) VMInputArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VMInputArrayOutput)
}

type VMInputOutput struct{ *pulumi.OutputState }

func (VMInputOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*VMInput)(nil)).Elem()
}

func (o VMInputOutput) ToVMInputOutput() VMInputOutput {
	return o
}

func (o VMInputOutput) ToVMInputOutputWithContext(ctx context.Context) VMInputOutput {
	return o
}

func (o VMInputOutput) Cpu() pulumi.IntOutput {
	return o.ApplyT(func(v VMInput) int { return v.Cpu }).(pulumi.IntOutput)
}

func (o VMInputOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VMInput) *string { return v.Description }).(pulumi.StringPtrOutput)
}

func (o VMInputOutput) Entrypoint() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VMInput) *string { return v.Entrypoint }).(pulumi.StringPtrOutput)
}

func (o VMInputOutput) Env_vars() pulumi.StringMapOutput {
	return o.ApplyT(func(v VMInput) map[string]string { return v.Env_vars }).(pulumi.StringMapOutput)
}

func (o VMInputOutput) Flist() pulumi.StringOutput {
	return o.ApplyT(func(v VMInput) string { return v.Flist }).(pulumi.StringOutput)
}

func (o VMInputOutput) Flist_checksum() pulumi.StringPtrOutput {
	return o.ApplyT(func(v VMInput) *string { return v.Flist_checksum }).(pulumi.StringPtrOutput)
}

func (o VMInputOutput) Gpus() pulumi.StringArrayOutput {
	return o.ApplyT(func(v VMInput) []string { return v.Gpus }).(pulumi.StringArrayOutput)
}

func (o VMInputOutput) Memory() pulumi.IntOutput {
	return o.ApplyT(func(v VMInput) int { return v.Memory }).(pulumi.IntOutput)
}

func (o VMInputOutput) Mounts() MountArrayOutput {
	return o.ApplyT(func(v VMInput) []Mount { return v.Mounts }).(MountArrayOutput)
}

func (o VMInputOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v VMInput) string { return v.Name }).(pulumi.StringOutput)
}

func (o VMInputOutput) Network_name() pulumi.StringOutput {
	return o.ApplyT(func(v VMInput) string { return v.Network_name }).(pulumi.StringOutput)
}

func (o VMInputOutput) Planetary() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VMInput) *bool { return v.Planetary }).(pulumi.BoolPtrOutput)
}

func (o VMInputOutput) Public_ip() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VMInput) *bool { return v.Public_ip }).(pulumi.BoolPtrOutput)
}

func (o VMInputOutput) Public_ip6() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v VMInput) *bool { return v.Public_ip6 }).(pulumi.BoolPtrOutput)
}

func (o VMInputOutput) Rootfs_size() pulumi.IntPtrOutput {
	return o.ApplyT(func(v VMInput) *int { return v.Rootfs_size }).(pulumi.IntPtrOutput)
}

func (o VMInputOutput) Zlogs() ZlogArrayOutput {
	return o.ApplyT(func(v VMInput) []Zlog { return v.Zlogs }).(ZlogArrayOutput)
}

type VMInputArrayOutput struct{ *pulumi.OutputState }

func (VMInputArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]VMInput)(nil)).Elem()
}

func (o VMInputArrayOutput) ToVMInputArrayOutput() VMInputArrayOutput {
	return o
}

func (o VMInputArrayOutput) ToVMInputArrayOutputWithContext(ctx context.Context) VMInputArrayOutput {
	return o
}

func (o VMInputArrayOutput) Index(i pulumi.IntInput) VMInputOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) VMInput {
		return vs[0].([]VMInput)[vs[1].(int)]
	}).(VMInputOutput)
}

type ZDBComputed struct {
	Ips       []string `pulumi:"ips"`
	Namespace string   `pulumi:"namespace"`
	Port      int      `pulumi:"port"`
}

// ZDBComputedInput is an input type that accepts ZDBComputedArgs and ZDBComputedOutput values.
// You can construct a concrete instance of `ZDBComputedInput` via:
//
//	ZDBComputedArgs{...}
type ZDBComputedInput interface {
	pulumi.Input

	ToZDBComputedOutput() ZDBComputedOutput
	ToZDBComputedOutputWithContext(context.Context) ZDBComputedOutput
}

type ZDBComputedArgs struct {
	Ips       pulumi.StringArrayInput `pulumi:"ips"`
	Namespace pulumi.StringInput      `pulumi:"namespace"`
	Port      pulumi.IntInput         `pulumi:"port"`
}

func (ZDBComputedArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ZDBComputed)(nil)).Elem()
}

func (i ZDBComputedArgs) ToZDBComputedOutput() ZDBComputedOutput {
	return i.ToZDBComputedOutputWithContext(context.Background())
}

func (i ZDBComputedArgs) ToZDBComputedOutputWithContext(ctx context.Context) ZDBComputedOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ZDBComputedOutput)
}

// ZDBComputedArrayInput is an input type that accepts ZDBComputedArray and ZDBComputedArrayOutput values.
// You can construct a concrete instance of `ZDBComputedArrayInput` via:
//
//	ZDBComputedArray{ ZDBComputedArgs{...} }
type ZDBComputedArrayInput interface {
	pulumi.Input

	ToZDBComputedArrayOutput() ZDBComputedArrayOutput
	ToZDBComputedArrayOutputWithContext(context.Context) ZDBComputedArrayOutput
}

type ZDBComputedArray []ZDBComputedInput

func (ZDBComputedArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ZDBComputed)(nil)).Elem()
}

func (i ZDBComputedArray) ToZDBComputedArrayOutput() ZDBComputedArrayOutput {
	return i.ToZDBComputedArrayOutputWithContext(context.Background())
}

func (i ZDBComputedArray) ToZDBComputedArrayOutputWithContext(ctx context.Context) ZDBComputedArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ZDBComputedArrayOutput)
}

type ZDBComputedOutput struct{ *pulumi.OutputState }

func (ZDBComputedOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ZDBComputed)(nil)).Elem()
}

func (o ZDBComputedOutput) ToZDBComputedOutput() ZDBComputedOutput {
	return o
}

func (o ZDBComputedOutput) ToZDBComputedOutputWithContext(ctx context.Context) ZDBComputedOutput {
	return o
}

func (o ZDBComputedOutput) Ips() pulumi.StringArrayOutput {
	return o.ApplyT(func(v ZDBComputed) []string { return v.Ips }).(pulumi.StringArrayOutput)
}

func (o ZDBComputedOutput) Namespace() pulumi.StringOutput {
	return o.ApplyT(func(v ZDBComputed) string { return v.Namespace }).(pulumi.StringOutput)
}

func (o ZDBComputedOutput) Port() pulumi.IntOutput {
	return o.ApplyT(func(v ZDBComputed) int { return v.Port }).(pulumi.IntOutput)
}

type ZDBComputedArrayOutput struct{ *pulumi.OutputState }

func (ZDBComputedArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ZDBComputed)(nil)).Elem()
}

func (o ZDBComputedArrayOutput) ToZDBComputedArrayOutput() ZDBComputedArrayOutput {
	return o
}

func (o ZDBComputedArrayOutput) ToZDBComputedArrayOutputWithContext(ctx context.Context) ZDBComputedArrayOutput {
	return o
}

func (o ZDBComputedArrayOutput) Index(i pulumi.IntInput) ZDBComputedOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ZDBComputed {
		return vs[0].([]ZDBComputed)[vs[1].(int)]
	}).(ZDBComputedOutput)
}

type ZDBInput struct {
	Description *string `pulumi:"description"`
	Mode        *string `pulumi:"mode"`
	Name        string  `pulumi:"name"`
	Password    string  `pulumi:"password"`
	Public      *bool   `pulumi:"public"`
	Size        int     `pulumi:"size"`
}

// Defaults sets the appropriate defaults for ZDBInput
func (val *ZDBInput) Defaults() *ZDBInput {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Mode == nil {
		if d := internal.GetEnvOrDefault("user", nil, ""); d != nil {
			mode_ := d.(string)
			tmp.Mode = &mode_
		}
	}
	return &tmp
}

// ZDBInputInput is an input type that accepts ZDBInputArgs and ZDBInputOutput values.
// You can construct a concrete instance of `ZDBInputInput` via:
//
//	ZDBInputArgs{...}
type ZDBInputInput interface {
	pulumi.Input

	ToZDBInputOutput() ZDBInputOutput
	ToZDBInputOutputWithContext(context.Context) ZDBInputOutput
}

type ZDBInputArgs struct {
	Description pulumi.StringPtrInput `pulumi:"description"`
	Mode        pulumi.StringPtrInput `pulumi:"mode"`
	Name        pulumi.StringInput    `pulumi:"name"`
	Password    pulumi.StringInput    `pulumi:"password"`
	Public      pulumi.BoolPtrInput   `pulumi:"public"`
	Size        pulumi.IntInput       `pulumi:"size"`
}

// Defaults sets the appropriate defaults for ZDBInputArgs
func (val *ZDBInputArgs) Defaults() *ZDBInputArgs {
	if val == nil {
		return nil
	}
	tmp := *val
	if tmp.Mode == nil {
		if d := internal.GetEnvOrDefault("user", nil, ""); d != nil {
			tmp.Mode = pulumi.StringPtr(d.(string))
		}
	}
	return &tmp
}
func (ZDBInputArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ZDBInput)(nil)).Elem()
}

func (i ZDBInputArgs) ToZDBInputOutput() ZDBInputOutput {
	return i.ToZDBInputOutputWithContext(context.Background())
}

func (i ZDBInputArgs) ToZDBInputOutputWithContext(ctx context.Context) ZDBInputOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ZDBInputOutput)
}

// ZDBInputArrayInput is an input type that accepts ZDBInputArray and ZDBInputArrayOutput values.
// You can construct a concrete instance of `ZDBInputArrayInput` via:
//
//	ZDBInputArray{ ZDBInputArgs{...} }
type ZDBInputArrayInput interface {
	pulumi.Input

	ToZDBInputArrayOutput() ZDBInputArrayOutput
	ToZDBInputArrayOutputWithContext(context.Context) ZDBInputArrayOutput
}

type ZDBInputArray []ZDBInputInput

func (ZDBInputArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ZDBInput)(nil)).Elem()
}

func (i ZDBInputArray) ToZDBInputArrayOutput() ZDBInputArrayOutput {
	return i.ToZDBInputArrayOutputWithContext(context.Background())
}

func (i ZDBInputArray) ToZDBInputArrayOutputWithContext(ctx context.Context) ZDBInputArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ZDBInputArrayOutput)
}

type ZDBInputOutput struct{ *pulumi.OutputState }

func (ZDBInputOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ZDBInput)(nil)).Elem()
}

func (o ZDBInputOutput) ToZDBInputOutput() ZDBInputOutput {
	return o
}

func (o ZDBInputOutput) ToZDBInputOutputWithContext(ctx context.Context) ZDBInputOutput {
	return o
}

func (o ZDBInputOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ZDBInput) *string { return v.Description }).(pulumi.StringPtrOutput)
}

func (o ZDBInputOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v ZDBInput) *string { return v.Mode }).(pulumi.StringPtrOutput)
}

func (o ZDBInputOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v ZDBInput) string { return v.Name }).(pulumi.StringOutput)
}

func (o ZDBInputOutput) Password() pulumi.StringOutput {
	return o.ApplyT(func(v ZDBInput) string { return v.Password }).(pulumi.StringOutput)
}

func (o ZDBInputOutput) Public() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v ZDBInput) *bool { return v.Public }).(pulumi.BoolPtrOutput)
}

func (o ZDBInputOutput) Size() pulumi.IntOutput {
	return o.ApplyT(func(v ZDBInput) int { return v.Size }).(pulumi.IntOutput)
}

type ZDBInputArrayOutput struct{ *pulumi.OutputState }

func (ZDBInputArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ZDBInput)(nil)).Elem()
}

func (o ZDBInputArrayOutput) ToZDBInputArrayOutput() ZDBInputArrayOutput {
	return o
}

func (o ZDBInputArrayOutput) ToZDBInputArrayOutputWithContext(ctx context.Context) ZDBInputArrayOutput {
	return o
}

func (o ZDBInputArrayOutput) Index(i pulumi.IntInput) ZDBInputOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ZDBInput {
		return vs[0].([]ZDBInput)[vs[1].(int)]
	}).(ZDBInputOutput)
}

type Zlog struct {
	Output   string `pulumi:"output"`
	Zmachine string `pulumi:"zmachine"`
}

// ZlogInput is an input type that accepts ZlogArgs and ZlogOutput values.
// You can construct a concrete instance of `ZlogInput` via:
//
//	ZlogArgs{...}
type ZlogInput interface {
	pulumi.Input

	ToZlogOutput() ZlogOutput
	ToZlogOutputWithContext(context.Context) ZlogOutput
}

type ZlogArgs struct {
	Output   pulumi.StringInput `pulumi:"output"`
	Zmachine pulumi.StringInput `pulumi:"zmachine"`
}

func (ZlogArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*Zlog)(nil)).Elem()
}

func (i ZlogArgs) ToZlogOutput() ZlogOutput {
	return i.ToZlogOutputWithContext(context.Background())
}

func (i ZlogArgs) ToZlogOutputWithContext(ctx context.Context) ZlogOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ZlogOutput)
}

// ZlogArrayInput is an input type that accepts ZlogArray and ZlogArrayOutput values.
// You can construct a concrete instance of `ZlogArrayInput` via:
//
//	ZlogArray{ ZlogArgs{...} }
type ZlogArrayInput interface {
	pulumi.Input

	ToZlogArrayOutput() ZlogArrayOutput
	ToZlogArrayOutputWithContext(context.Context) ZlogArrayOutput
}

type ZlogArray []ZlogInput

func (ZlogArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Zlog)(nil)).Elem()
}

func (i ZlogArray) ToZlogArrayOutput() ZlogArrayOutput {
	return i.ToZlogArrayOutputWithContext(context.Background())
}

func (i ZlogArray) ToZlogArrayOutputWithContext(ctx context.Context) ZlogArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ZlogArrayOutput)
}

type ZlogOutput struct{ *pulumi.OutputState }

func (ZlogOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Zlog)(nil)).Elem()
}

func (o ZlogOutput) ToZlogOutput() ZlogOutput {
	return o
}

func (o ZlogOutput) ToZlogOutputWithContext(ctx context.Context) ZlogOutput {
	return o
}

func (o ZlogOutput) Output() pulumi.StringOutput {
	return o.ApplyT(func(v Zlog) string { return v.Output }).(pulumi.StringOutput)
}

func (o ZlogOutput) Zmachine() pulumi.StringOutput {
	return o.ApplyT(func(v Zlog) string { return v.Zmachine }).(pulumi.StringOutput)
}

type ZlogArrayOutput struct{ *pulumi.OutputState }

func (ZlogArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Zlog)(nil)).Elem()
}

func (o ZlogArrayOutput) ToZlogArrayOutput() ZlogArrayOutput {
	return o
}

func (o ZlogArrayOutput) ToZlogArrayOutputWithContext(ctx context.Context) ZlogArrayOutput {
	return o
}

func (o ZlogArrayOutput) Index(i pulumi.IntInput) ZlogOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Zlog {
		return vs[0].([]Zlog)[vs[1].(int)]
	}).(ZlogOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*BackendInput)(nil)).Elem(), BackendArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*BackendArrayInput)(nil)).Elem(), BackendArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DiskInput)(nil)).Elem(), DiskArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*DiskArrayInput)(nil)).Elem(), DiskArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*GroupInput)(nil)).Elem(), GroupArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*GroupArrayInput)(nil)).Elem(), GroupArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*K8sNodeComputedInput)(nil)).Elem(), K8sNodeComputedArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*K8sNodeComputedMapInput)(nil)).Elem(), K8sNodeComputedMap{})
	pulumi.RegisterInputType(reflect.TypeOf((*K8sNodeInputInput)(nil)).Elem(), K8sNodeInputArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*K8sNodeInputArrayInput)(nil)).Elem(), K8sNodeInputArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*MetadataInput)(nil)).Elem(), MetadataArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MountInput)(nil)).Elem(), MountArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*MountArrayInput)(nil)).Elem(), MountArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*QSFSComputedInput)(nil)).Elem(), QSFSComputedArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*QSFSComputedArrayInput)(nil)).Elem(), QSFSComputedArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*QSFSInputInput)(nil)).Elem(), QSFSInputArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*QSFSInputArrayInput)(nil)).Elem(), QSFSInputArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*VMComputedInput)(nil)).Elem(), VMComputedArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VMComputedArrayInput)(nil)).Elem(), VMComputedArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*VMInputInput)(nil)).Elem(), VMInputArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*VMInputArrayInput)(nil)).Elem(), VMInputArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ZDBComputedInput)(nil)).Elem(), ZDBComputedArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ZDBComputedArrayInput)(nil)).Elem(), ZDBComputedArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ZDBInputInput)(nil)).Elem(), ZDBInputArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ZDBInputArrayInput)(nil)).Elem(), ZDBInputArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ZlogInput)(nil)).Elem(), ZlogArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*ZlogArrayInput)(nil)).Elem(), ZlogArray{})
	pulumi.RegisterOutputType(BackendOutput{})
	pulumi.RegisterOutputType(BackendArrayOutput{})
	pulumi.RegisterOutputType(DiskOutput{})
	pulumi.RegisterOutputType(DiskArrayOutput{})
	pulumi.RegisterOutputType(GroupOutput{})
	pulumi.RegisterOutputType(GroupArrayOutput{})
	pulumi.RegisterOutputType(K8sNodeComputedOutput{})
	pulumi.RegisterOutputType(K8sNodeComputedMapOutput{})
	pulumi.RegisterOutputType(K8sNodeInputOutput{})
	pulumi.RegisterOutputType(K8sNodeInputArrayOutput{})
	pulumi.RegisterOutputType(MetadataOutput{})
	pulumi.RegisterOutputType(MountOutput{})
	pulumi.RegisterOutputType(MountArrayOutput{})
	pulumi.RegisterOutputType(QSFSComputedOutput{})
	pulumi.RegisterOutputType(QSFSComputedArrayOutput{})
	pulumi.RegisterOutputType(QSFSInputOutput{})
	pulumi.RegisterOutputType(QSFSInputArrayOutput{})
	pulumi.RegisterOutputType(VMComputedOutput{})
	pulumi.RegisterOutputType(VMComputedArrayOutput{})
	pulumi.RegisterOutputType(VMInputOutput{})
	pulumi.RegisterOutputType(VMInputArrayOutput{})
	pulumi.RegisterOutputType(ZDBComputedOutput{})
	pulumi.RegisterOutputType(ZDBComputedArrayOutput{})
	pulumi.RegisterOutputType(ZDBInputOutput{})
	pulumi.RegisterOutputType(ZDBInputArrayOutput{})
	pulumi.RegisterOutputType(ZlogOutput{})
	pulumi.RegisterOutputType(ZlogArrayOutput{})
}
